<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radial Pattern Explorer</title>

  <!-- Import map for React, ReactDOM and D3 (esm.sh) -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "d3": "https://esm.sh/d3@7.8.5"
    }
  }
  </script>

  <!-- tsx loader (keeps JSX/TSX in browser) -->
  <script type="module" src="https://esm.sh/tsx"></script>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

  <style>
    /* small extra tweaks */
    html,body { height: 100%; }
    .no-select { user-select: none; -webkit-user-select:none; -moz-user-select:none; }
    /* ensure svg scales nicely in the central pane */
    svg { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body class="bg-slate-50">

  <div id="root"></div>

  <script type="text/babel">
    import React, { useState, useRef, useEffect, useMemo } from "react";
    import { createRoot } from "react-dom/client";
    import * as d3 from "d3";

    /******************************
     * Utilities
     ******************************/
    const uid = () =>
      Math.random().toString(36).slice(2, 9);

    // compute radial points from a center, radius and count
    function computeRadialPoints({ x, y }, radius, count) {
      if (count <= 0) return [];
      const angles = d3.range(count).map(i => (i / count) * Math.PI * 2);
      return angles.map(a => ({
        x: x + Math.cos(a) * radius,
        y: y + Math.sin(a) * radius,
        angle: a
      }));
    }

    /******************************
     * Default values
     ******************************/
    const DEFAULT_TOOL = "radial";
    const DEFAULT_RADIAL = {
      type: "radial",
      shape: "dot", // dot | line | circle
      radius: 80,
      count: 8,
    };

    /******************************
     * Main App
     ******************************/
    function App() {
      // transformations list
      const [transforms, setTransforms] = useState([]);
      const [selectedId, setSelectedId] = useState(null);
      // active tool in the left control (for future expansion)
      const [activeTool, setActiveTool] = useState(DEFAULT_TOOL);

      // Add a new radial transformation at position
      function addRadialAt(pos) {
        const t = {
          id: uid(),
          type: "radial",
          shape: DEFAULT_RADIAL.shape,
          radius: DEFAULT_RADIAL.radius,
          count: DEFAULT_RADIAL.count,
          position: pos
        };
        setTransforms(prev => [...prev, t]);
        setSelectedId(t.id);
      }

      function updateTransform(id, patch) {
        setTransforms(prev => prev.map(t => (t.id === id ? { ...t, ...patch } : t)));
      }

      function deleteTransform(id) {
        setTransforms(prev => prev.filter(t => t.id !== id));
        if (selectedId === id) setSelectedId(null);
      }

      const selected = transforms.find(t => t.id === selectedId) || null;

      return (
        <div className="flex gap-2 h-screen p-2 *:min-w-0">
          <div className="p-2 basis-1/25 grow max-w-1/3 bg-sky-50 rounded-md shadow-sm max-w-1/4">
            <ViewControls
              activeTool={activeTool}
              setActiveTool={setActiveTool}
              selected={selected}
              onChange={(patch) => selected && updateTransform(selected.id, patch)}
              onDelete={() => selected && deleteTransform(selected.id)}
              onCreateDefault={() => setActiveTool(DEFAULT_TOOL)}
            />
          </div>

          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="p-2 basis-1/5 grow bg-white rounded-md drop-shadow-sm min-w-1/2"
            onClick={(e) => {
              // compute click relative to svg bounding box
              const svg = e.currentTarget;
              const rect = svg.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              addRadialAt({ x, y });
            }}
          >
            <g>
              <PatternCanvas
                transforms={transforms}
                selectedId={selectedId}
                onSelect={(id) => setSelectedId(id)}
                onUpdatePosition={(id, pos) => updateTransform(id, { position: pos })}
              />
            </g>
          </svg>

          <div className="p-2 basis-1/25 grow max-w-100 bg-sky-50 rounded-md shadow-sm  max-w-1/4">
            <TransformationList
              transforms={transforms}
              selectedId={selectedId}
              onSelect={(id) => setSelectedId(id)}
              onDelete={(id) => deleteTransform(id)}
            />
          </div>
        </div>
      );
    }

    /******************************
     * View Controls (left panel)
     ******************************/
    function ViewControls({ activeTool, setActiveTool, selected, onChange, onDelete }) {
      // If nothing selected, show tool selection and small help
      if (!selected) {
        return (
          <div className="no-select">
            <h3 className="text-lg font-semibold mb-2">View Controls</h3>
            <div className="mb-3 text-sm">Select a transformation from the list (right) to edit it here.</div>

            <div className="mb-4">
              <label className="block text-xs font-medium text-slate-700 mb-1">Active scaffolding tool</label>
              <select
                value={activeTool}
                onChange={e => setActiveTool(e.target.value)}
                className="w-full p-1 border rounded"
              >
                <option value="radial">Radial Repetition (prototype)</option>
                {/* future tools will be added here */}
              </select>
            </div>

            <div className="text-xs text-slate-600">
              Interaction:
              <ul className="list-disc pl-4 mt-1">
                <li>Click canvas to create a radial scaffolding (center = click)</li>
                <li>Select an entry on the right to edit/delete</li>
                <li>Scaffolding lines are guides; shapes are the actual drawing</li>
              </ul>
            </div>
          </div>
        );
      }

      // Selected transformation editor
      const { id, type, shape, radius, count, position } = selected;

      function update(patch) {
        onChange(patch);
      }

      return (
        <div className="no-select">
          <h3 className="text-lg font-semibold mb-2">View Controls</h3>

          <div className="mb-2 text-sm">Editing: <span className="font-medium">{type} Â· {id.slice(0,5)}</span></div>

          <div className="space-y-3">
            <div>
              <label className="block text-xs font-medium text-slate-700">Shape</label>
              <select
                value={shape}
                onChange={e => update({ shape: e.target.value })}
                className="w-full p-1 border rounded"
              >
                <option value="dot">dot</option>
                <option value="line">line</option>
                <option value="circle">circle</option>
              </select>
            </div>

            <div>
              <label className="block text-xs font-medium text-slate-700">Count <span className="text-slate-500 text-xs">({count})</span></label>
              <input
                type="range"
                min="1"
                max="64"
                value={count}
                onChange={e => update({ count: Math.max(1, Math.round(+e.target.value)) })}
                className="w-full"
              />
            </div>

            <div>
              <label className="block text-xs font-medium text-slate-700">Radius <span className="text-slate-500 text-xs">({radius}px)</span></label>
              <input
                type="range"
                min="8"
                max="500"
                value={radius}
                onChange={e => update({ radius: Math.max(0, Math.round(+e.target.value)) })}
                className="w-full"
              />
            </div>

            <div>
              <label className="block text-xs font-medium text-slate-700">Position</label>
              <div className="flex gap-2">
                <input
                  type="number"
                  value={Math.round(position.x)}
                  onChange={e => update({ position: { x: Number(e.target.value), y: position.y } })}
                  className="w-1/2 p-1 border rounded"
                />
                <input
                  type="number"
                  value={Math.round(position.y)}
                  onChange={e => update({ position: { x: position.x, y: Number(e.target.value) } })}
                  className="w-1/2 p-1 border rounded"
                />
              </div>
              <div className="mt-1 text-xs text-slate-500">You can also reposition quickly by clicking the canvas to create a new transform and deleting the old one, or edit numerically here.</div>
            </div>

            <div className="flex gap-2">
              <button
                onClick={() => onDelete()}
                className="flex-1 bg-red-500 hover:bg-red-600 text-white py-1 rounded"
              >
                Delete transformation
              </button>
            </div>
          </div>
        </div>
      );
    }

    /******************************
     * PatternCanvas (middle SVG)
     *
     * Renders scaffolding + shapes for all transforms.
     ******************************/
    function PatternCanvas({ transforms, selectedId, onSelect, onUpdatePosition }) {
      // We use memoization for computed points to avoid recompute blasts.
      const computed = useMemo(() => {
        return transforms.map(t => {
          if (t.type === "radial") {
            const points = computeRadialPoints(t.position, t.radius, t.count);
            return { ...t, _points: points };
          }
          return { ...t, _points: [] };
        });
      }, [transforms]);

      // Render each transformation: scaffolding first, shapes on top.
      return (
        <g>
          {computed.map(t => (
            <g key={t.id}>
              {/* scaffolding potentials */}
              <g>
                {t._points.map((p, i) => (
                  <line
                    key={"s-" + i}
                    x1={t.position.x}
                    y1={t.position.y}
                    x2={p.x}
                    y2={p.y}
                    stroke="#9AAED0"
                    strokeWidth={1}
                    strokeDasharray="4 4"
                    opacity={0.7}
                  />
                ))}
                {/* optional center marker for selected */}
                {selectedId === t.id && (
                  <circle cx={t.position.x} cy={t.position.y} r={6} fill="#2563EB" opacity={0.9} />
                )}
              </g>

              {/* shapes (the actual drawing) */}
              <g>
                {t._points.map((p, i) => {
                  if (t.shape === "dot") {
                    return (
                      <circle
                        key={"g-dot-" + i}
                        cx={p.x}
                        cy={p.y}
                        r={6}
                        fill="#0F172A"
                      />
                    );
                  } else if (t.shape === "circle") {
                    return (
                      <circle
                        key={"g-circle-" + i}
                        cx={p.x}
                        cy={p.y}
                        r={12}
                        fill="none"
                        stroke="#0F172A"
                        strokeWidth={2}
                      />
                    );
                  } else if (t.shape === "line") {
                    // small outward line segment at the end of the scaffold
                    const len = Math.min(28, Math.max(8, t.radius * 0.2));
                    const x2 = p.x + Math.cos(p.angle) * len;
                    const y2 = p.y + Math.sin(p.angle) * len;
                    return (
                      <line
                        key={"g-line-" + i}
                        x1={p.x}
                        y1={p.y}
                        x2={x2}
                        y2={y2}
                        stroke="#0F172A"
                        strokeWidth={2}
                        strokeLinecap="round"
                      />
                    );
                  }
                  return null;
                })}
              </g>

              {/* clickable invisible hit area to select / drag center */}
              <rect
                x={t.position.x - 16}
                y={t.position.y - 16}
                width={32}
                height={32}
                fill="transparent"
                style={{ cursor: "pointer" }}
                onClick={(e) => {
                  // stop propagation so svg click doesn't create a new transform
                  e.stopPropagation();
                  onSelect(t.id);
                }}
                onDoubleClick={(e) => {
                  // allow double-clicking the center to move it to pointer (demonstration)
                  e.stopPropagation();
                  // compute pointer relative position
                  const svg = e.currentTarget.ownerSVGElement;
                  const rect = svg.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const y = e.clientY - rect.top;
                  onUpdatePosition(t.id, { x, y });
                }}
                title="Click to select. Double-click to reposition center."
              />
            </g>
          ))}
        </g>
      );
    }

    /******************************
     * TransformationList (right panel)
     ******************************/
    function TransformationList({ transforms, selectedId, onSelect, onDelete }) {
      return (
        <div>
          <h3 className="text-lg font-semibold mb-2">Transformation Controls</h3>
          <div className="text-sm mb-3">Click an entry to select it and load its controls in the left panel.</div>

          <div className="space-y-2 overflow-auto" style={{ maxHeight: "72vh" }}>
            {transforms.length === 0 && (
              <div className="p-2 text-sm text-slate-600">No transformations yet â click the canvas to create one.</div>
            )}

            {transforms.map(t => (
              <div
                key={t.id}
                className={`p-2 rounded border ${selectedId === t.id ? "border-blue-500 bg-blue-50" : "border-slate-200 bg-white"} flex items-center justify-between`}
              >
                <div className="min-w-0">
                  <div className="text-sm font-medium truncate">{t.type} Â· {t.id.slice(0,6)}</div>
                  <div className="text-xs text-slate-500 truncate">
                    shape: {t.shape} Â· count: {t.count} Â· radius: {t.radius}px
                  </div>
                </div>

                <div className="flex gap-2 ml-3">
                  <button
                    className="px-2 py-1 text-xs border rounded hover:bg-slate-100"
                    onClick={() => onSelect(t.id)}
                  >
                    Select
                  </button>
                  <button
                    className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                    onClick={() => onDelete(t.id)}
                  >
                    Delete
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    /******************************
     * Render
     ******************************/
    createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
